<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="stylesheet" href="..\css\p.css">
    <title>Document</title>
</head>
<body>
  <header>
    <nav class="container">
        <div class="left">
           <div class="logo"><a href="/">logo</a></div> 
            <ul>
               <li> <a href="/">Home</a></li>
               <li> <a href="Program.html">Program</a></li>
               <li> <a href="about.html">About</a></li>
             
            </ul>
    </div>
    </nav>
  </header>
  <div class="text">
  <nav>
  <div class="partion">
    <table border="1">
  <tr><th> <h1>Programs</h1></th></tr>
   <tr><td><h3>
   <a href="section1">Decimal To Binary</a> </h3>
   </td></tr>
   <tr><td><h3><a href="#section2">Binary To Decimal</a></h3></td></tr>
   <tr><td><h3><a href="#section3">Addition, Subtraction, Multiplication, Division</a></h3></td></tr>
   <tr><td><h3><a href="#section4">Bisection Method</a></h3></td></tr>
   <tr><td><h3><a href="#section5">Regula Falsi</a></h3></td></tr>
   <tr><td><h3><a href="#section6">Secant Method</a></h3></td></tr>
   <tr><td><h3><a href="#section7">Newton Raphson Method</a></h3></td></tr>
   <tr><td><h3><a href="#section8">Gauss Elimination Method</a></h3></td></tr>
   <tr><td><h3><a href="#section9">Gauss Jordan Method</a></h3></td></tr>
   <tr><td><h3><a href="#section10">Gauss Seidel Method</a></h3></td></tr>
   <tr><td><h3><a href="#section11">Lagrange's Interpolation Method</a></h3></td></tr>
   <tr><td><h3><a href="#section12">Lagrange's Inverse Interpolation Method</a></h3></td></tr>
   <tr><td><h3><a href="#section13">Newton Forward difference Method</a></h3></td></tr>
   <tr><td><h3><a href="#section14">Newton Backward difference Method</a></h3></td></tr>
   <tr><td><h3><a href="#section15">Newton's Divided Difference Method</a></h3></td></tr>
   <tr><td><h3><a href="#section16">Trapzoidal Rule Method</a></h3></td></tr>
   <tr><td><h3><a href="#section17">Simpson 1/3 th Rule Method</a></h3></td></tr>
   <tr><td><h3><a href="#section18">Simpson 3/8 th Rule Method</a></h3></td></tr>
   <!-- <tr><td><h3><a href="#">Gauss Seidel Method</a></h3></td></tr> -->
    <tr><td><h3><a href="#section19">Taylor Series Representation</a></h3></td></tr>
    <tr><td><h3><a href="#section20">Chebyshev Polynomials</a></h3></td></tr>
    <tr><td><h3><a href="#section21">Euler’s Method</a></h3></td></tr>
    <tr><td><h3><a href="#section22">Runga–Kutta Methods: 2nd order</a></h3></td></tr>
    <tr><td><h3><a href="#section23">Runga–Kutta Methods: 4th order</a></h3></td></tr>
    <tr><td><h3><a href="#section24"> Modified Euler’s Method.</a></h3></td></tr>
  
      </table>
      </div>
    </nav>
     <section>
      <div id="section1">
        <h3>1.Decimal To Binary</h3>
        <br>
        <h4>Code : </h4>
        <br>
        <div class="sec1">
            <pre>
  #include < stdio.h >

  int main() {
    int decimal_num, binary_num[32], i = 0;
                
    printf("Enter a decimal number: ");
    scanf("%d", &decimal_num);
                
    if (decimal_num == 0) {
        return 0;
    }
                
    while (decimal_num > 0) {
        binary_num[i] = decimal_num % 2;  
        decimal_num /= 2;                
        i++;
    }
                
    printf("The binary representation is: ");
    for (int j = i - 1; j >= 0; j--) {
        printf("%d", binary_num[j]);
    }
    printf("\n");
                
    return 0;
  }
                
            </pre>
        </div>
        <div class="sec2">
           
        <h4>Output : </h4>
        <br>
        <pre>
  Enter a decimal number: 10
  The binary representation is: 1010     
  </pre>
        </div>
      </div>
    <div id="section2">
        <h3>2.Binary To Decimal</h3>
        <br>
        <h4>Code : </h4>
        <br>
        <div class="sec1">
            <pre>
  #include < stdio.h >
  #include < string.h >
  #include < math.h >
                
  int main() {
      char binary_num[100];
      int decimal_num = 0, length;
                
      printf("Enter a binary number: ");
      scanf("%s", binary_num);
                
      length = strlen(binary_num);
                
      for (int i = 0; i < length; i++) {
          if (binary_num[i] == '1') {
                            
              decimal_num += pow(2, length - i - 1);
          } else if (binary_num[i] != '0') {
                           
              printf("Invalid binary number!\n");
              return 0;
          }
      }
                
      printf("The decimal representation of binary %s is
       %d\n", binary_num, decimal_num);
                
      return 0;
  }
                
            </pre>
        </div>
        <div class="sec2">
          
            <h4>Output : </h4>
            <br>
            <pre>
  Enter a binary number: 1111
  The decimal representation of binary 1111 is 15
            </pre>
        </div>
    </div>
    <div id="section3">
        <h3>3.Bisection Method</h3>
        <br>
        <h4>Code : </h4>
        <br>
        <div class="sec1">
        <pre>
  #include < stdio.h >
  #include < math.h >
            
  double f(double x) {
      return x * x - 4;  
  }
            
  int main() {
      double a, b, c, tol;
      int max_iterations, iter = 0;
    
      printf("Enter the initial interval [a, b] where f(a) 
      and f(b) have opposite signs:\n");
      scanf("%lf %lf", &a, &b);
            
      printf("Enter tolerance (e.g., 0.0001): ");
      scanf("%lf", &tol);
      printf("Enter maximum number of iterations: ");
      scanf("%d", &max_iterations);
            
      if (f(a) * f(b) >= 0) {
          printf("The function does not change sign over
           the interval [a, b].\n");
          return 1;
      }
      printf("\nIteration Details:\n");
      printf("Iteration\t a\t\t b\t\t c\t\t f(c)\n");
      printf("--------------------------------------------\n");
       
      do {
          c = (a + b) / 2; 
          double fc = f(c);
            
          printf("%d\t\t %.6lf\t %.6lf\t %.6lf\t %.6lf\n",
           iter + 1, a, b, c, fc);
            
          if (fc == 0.0) {
              printf("\nExact root found: %lf\n", c);
              return 0;
          }
            
          if (f(a) * fc < 0) {
              b = c;  // Root is in [a, c]
          } else {
              a = c;  // Root is in [c, b]
          }
            
          iter++;
      } while ((b - a) / 2 > tol && iter < max_iterations);
          
      printf("\nRoot approximation: %lf\n", c);
      printf("Number of iterations: %d\n", iter);
            
      return 0;
  }
            

        </pre>
        </div>
        <div class="sec2">
            <h4>Output : </h4>
            <br>
            <pre>
  Enter the initial interval [a, b] where f(a) and f(b) have opposite signs:
  1
  3
  Enter tolerance (e.g., 0.0001): 5
  Enter maximum number of iterations: 4
              
  Iteration Details:
  Iteration      a               b               c               f(c)
  -----------------------------------------------------------
  1                1.000000        3.000000        2.000000        0.000000
              
  Exact root found: 2.000000
            </pre>
        </div>
    </div>
    <div id="section4">
        <h3>4.Addition, Subtraction, Multiplication, Division</h3>
        <br>
        <h4>Code : </h4>
        <br>
        <div class="sec1">
            <pre>
#include <  stdio.h >
  void add(float a, float b);
  void subtract(float a, float b);
  void multiply(float a, float b);
  void divide(float a, float b);
  int main() 
  {
   int choice;
   float num1, num2;
   do 
  {
  
   printf("Arithmetic Operations Menu\n");
   printf("1. Addition\n");
   printf("2. Subtraction\n");
  printf("3. Multiplication\n");
   printf("4. Division\n");
   printf("5. Exit\n");
   printf("Enter your choice: ");
   scanf("%d", &choice);
        if (choice >= 1 && choice <= 4) 
  {
  
   printf("Enter two numbers: ");
   scanf("%f %f", &num1, &num2);
   }
    switch (choice) {
   case 1:
   add(num1, num2);
   break;
   case 2:
   subtract(num1, num2);
   break;
   case 3:
   multiply(num1, num2);
   break;
   case 4:
   divide(num1, num2);
   break;
       case 5:
       printf("Exiting...\n");
   break;
   default:
   printf("Invalid choice. Please try again.\n");
   break;
   }
     printf("\n");
     } while (choice != 5);
   return 0;
  }
  // Function definitions
  void add(float a, float b)
   {
     printf("Result: %.2f\n", a + b);
       }
  void subtract(float a, float b)
   {
   printf("Result: %.2f\n", a - b);
  }
  void multiply(float a, float b) 
  {
   printf("Result: %.2f\n", a * b);
  }
  void divide(float a, float b) 
  {
   if (b != 0) 
  {
      printf("Result: %.2f\n", a / b);
   } else 
  {
   printf("Error: Division by zero is not allowed.\n");
   }
  } 
  
                </pre>
                <br>
        </div>
        <div class="sec2">
            <h3> Output : </h3>
            <br>
            <pre>
  Arithmetic Operations Menu
  1. Addition
  2. Subtraction
  3. Multiplication
  4. Division
  5. Exit
  Enter your choice: 2
  Enter two numbers: 1
  3
  Result: -2.00
              
  Arithmetic Operations Menu
  1. Addition
  2. Subtraction
  3. Multiplication
  4. Division
  5. Exit
  Enter your choice: 1
  Enter two numbers: 6
  2
  Result: 8.00
              
  Arithmetic Operations Menu
  1. Addition
  2. Subtraction
  3. Multiplication
  4. Division
  5. Exit
  Enter your choice: 3
  Enter two numbers: 1.26
  20.3
  Result: 25.58
              
  Arithmetic Operations Menu
  1. Addition
  2. Subtraction
  3. Multiplication
  4. Division
  5. Exit
  Enter your choice: 4
  Enter two numbers: 3.2
  5
  Result: 0.64
              
  Arithmetic Operations Menu
  1. Addition
  2. Subtraction
  3. Multiplication
  4. Division
  5. Exit
  Enter your choice: 5
  Exiting...
            </pre>
        </div>
    </div>
    <div id="section5">
        <h3>5.Regula Falsi</h3>
        <br>
        <h4>Code :</h4>
        <br><div class="sec1">
            <pre>
  #include < stdio.h >
  #include < math.h >
  
  double f(double x) {
      return x * x - 4;  
  }
  
  int main() {
      double a, b, c, tol;
      int max_iterations, iter = 0;
  
      printf("Enter the initial interval [a, b] where 
      f(a) and f(b) have opposite signs:\n");
      scanf("%lf %lf", &a, &b);
  
      printf("Enter tolerance (e.g., 0.0001): ");
      scanf("%lf", &tol);
      printf("Enter maximum number of iterations: ");
      scanf("%d", &max_iterations);
  
      if (f(a) * f(b) >= 0) {
          printf("The function does not change sign over
           the interval [a, b].\n");
          return 1;
      }
  
      printf("\nIteration Details:\n");
      printf("Iteration\t a\t\t b\t\t c\t\t f(c)\n");
      printf("------------------------------------------\n");

      do {
          c = b - (f(b) * (b - a)) / (f(b) - f(a));
          double fc = f(c);
  
          printf("%d\t\t %.6lf\t %.6lf\t %.6lf\t %.6lf\n"
          , iter + 1, a, b, c, fc);
  
          if (fc == 0.0) {
              printf("\nExact root found: %lf\n", c);
              return 0;
          }
  
          if (f(a) * fc < 0) {
              b = c;  // Root is in [a, c]
          } else {
              a = c;  // Root is in [c, b]
          }
  
          iter++;
      } while (fabs(f(c)) > tol && iter < max_iterations);
  
      printf("\nRoot approximation: %lf\n", c);
      printf("Number of iterations: %d\n", iter);
  
      return 0;
  }
  
                    
            </pre>
        </div>
        <div class="sec2">
            <h4>Output : </h4>
            <br>
            <pre>
  Enter the initial interval [a, b] where f(a) and f(b) have 
  opposite signs:
  1
  3
  Enter tolerance (e.g., 0.0001): 5
  Enter maximum number of iterations: 2
              
  Iteration Details:
  Iteration        a               b               c               f(c)
  -----------------------------------------------------------
  1                1.000000        3.000000        1.750000        -0.937500
              
  Root approximation: 1.750000
  Number of iterations: 1 </pre>
        </div>
        
    </div>
    <div id="section6">
        <br>
        <h3>6.Secant Method</h3>
        <br>
        <h4>Code : </h4>
        <br>
        <div class="sec1">
            <pre>
  #include < stdio.h >
  #include < math.h >

  double f(double x) {
      return x * x - 4; 
  }
  
  int main() {
      double x0, x1, x2, tol;
      int max_iterations, iter = 0;
  
      printf("Enter the initial approximations x0 and x1:\n");
      scanf("%lf %lf", &x0, &x1);
      printf("Enter tolerance (e.g., 0.0001): ");
      scanf("%lf", &tol);
      printf("Enter maximum number of iterations: ");
      scanf("%d", &max_iterations);
  
      printf("\nIteration Details:\n");
      printf("Iteration\t x0\t\t x1\t\t x2\t\t f(x2)\n");
      printf("--------------------------------------------------\n");
  
      do {
          x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0));
          double fx2 = f(x2);
  
          printf("%d\t\t %.6lf\t %.6lf\t %.6lf\t %.6lf\n"
          ,iter + 1, x0, x1, x2, fx2);
  
          if (fabs(fx2) < tol) {
              printf("\nRoot approximation found: %lf\n", x2);
              return 0;
          }
  
          x0 = x1;
          x1 = x2;
  
          iter++;
      } while (fabs(x1 - x0) > tol && iter < max_iterations);
  
      // Print the result
      printf("\nRoot approximation: %lf\n", x2);
      printf("Number of iterations: %d\n", iter);
  
      return 0;
  }    
</pre>
        </div>
    
        <div class="sec2">
            <br>
            <h4>Output : </h4>
            <pre>
  Enter the initial approximations x0 and x1:
  2
  5
  Enter tolerance (e.g., 0.0001): 6
  Enter maximum number of iterations: 3
              
  Iteration Details:
  Iteration        x0              x1              x2              f(x2)
  -----------------------------------------------------------
  1                2.000000        5.000000        2.000000        0.000000
              
  Root approximation found: 2.000000  
        
    </div>
    </div>
    <div id="section7">
      <br>
      <h3>7.Newton Raphson Method</h3>
      <br>
      <h4>Code : </h4>
      <br>
      <div class="sec1">
          <pre>
#include < stdio.h >
#include < math.h >

// Define the function f(x) for which we want to find the root
double f(double x) {
    return x * x - 4;  // Example function: x^2 - 4
}

// Define the derivative f'(x) of the function
double df(double x) {
    return 2 * x;  // Derivative of x^2 - 4 is 2x
}

int main() {
    double x0, x1, tol;
    int max_iterations, iter = 0;

    // Input the initial approximation and parameters
    printf("Enter the initial approximation x0:\n");
    scanf("%lf", &x0);
    printf("Enter tolerance (e.g., 0.0001): ");
    scanf("%lf", &tol);
    printf("Enter maximum number of iterations: ");
    scanf("%d", &max_iterations);
    
    // Print header for iteration details
    printf("\nIteration Details:\n");
    printf("Iteration\t x0\t\t f(x0)\t\t f'(x0)\n");
    printf("-----------------------------------------------------------\n");

    // Newton-Raphson method
    do {
        double fx0 = f(x0);
        double dfx0 = df(x0);

        // Compute the next approximation
        x1 = x0 - fx0 / dfx0;

        // Print details for the current iteration
        printf("%d\t\t %.6lf\t %.6lf\t %.6lf\n", iter + 1, x0, fx0, dfx0);

        if (fabs(f(x1)) < tol) {
            printf("\nRoot approximation found: %lf\n", x1);
            return 0;
        }

        // Update x0 for the next iteration
        x0 = x1;
        iter++;
    } while (fabs(f(x1)) > tol && iter < max_iterations);

    // Print the result
    printf("\nRoot approximation: %lf\n", x1);
    printf("Number of iterations: %d\n", iter);

    return 0;
}
</pre>
      </div>
  
      <div class="sec2">
          <br>
          <h4>Output : </h4>
          <pre>
Enter the initial approximation x0:
5
Enter tolerance (e.g., 0.0001): 4
Enter maximum number of iterations: 3
            
Iteration Details:
Iteration        x0              f(x0)           f'(x0)
-----------------------------------------------------------
1                5.000000        21.000000       10.000000
2                2.900000        4.410000        5.800000
            
Root approximation found: 2.139655
</pre>
  </div>
  </div>
  <div id="section8">
    <br>
    <h3>8.Gauss Elimination Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
    #include < stdio.h >

    #define N 3  // Size of the matrix
    
    void printMatrix(double matrix[N][N+1]) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N+1; j++) {
                printf("%7.2lf ", matrix[i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }
    
    void gaussianElimination(double matrix[N][N+1]) {
        int i, j, k;
        double ratio;
    
        // Forward elimination
        for (i = 0; i < N; i++) {
        // Make the diagonal contain all ones and 
        eliminate elements below the diagonal
            for (j = i+1; j < N; j++) {
                ratio = matrix[j][i] / matrix[i][i];
                for (k = i; k < N+1; k++) {
                    matrix[j][k] -= ratio * matrix[i][k];
                }
            }
            // Print matrix after each step of forward elimination
            printf("Matrix after step %d of forward elimination:\n", i+1);
            printMatrix(matrix);
        }
        // Back substitution
        double x[N];
        for (i = N-1; i >= 0; i--) {
            x[i] = matrix[i][N] / matrix[i][i];
            for (j = i-1; j >= 0; j--) {
                matrix[j][N] -= matrix[j][i] * x[i];
            }
        }
    
        // Print the solution
        printf("Solution:\n");
        for (i = 0; i < N; i++) {
            printf("x%d = %.2lf\n", i+1, x[i]);
        }
    }
    
    int main() {
    double matrix[N][N+1] = {
        {2, -1, 1, 3},  // Example system: 2x - y + z = 3
        {1, 1, 1, 6},   //            x +   y + z = 6
        {1, -1, 2, 2}   //            x - y + 2z = 2
    };
    
    printf("Augmented Matrix:\n");
    printMatrix(matrix);
    
    gaussianElimination(matrix);
    
    return 0;
    }
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Augmented Matrix:
    2.00   -1.00    1.00    3.00
    1.00    1.00    1.00    6.00
    1.00   -1.00    2.00    2.00
 
    Matrix after step 1 of forward elimination:
    2.00   -1.00    1.00    3.00
    0.00    1.50    0.50    4.50
    0.00   -0.50    1.50    0.50
 
    Matrix after step 2 of forward elimination:
    2.00   -1.00    1.00    3.00
    0.00    1.50    0.50    4.50
    0.00    0.00    1.67    2.00
 
    Matrix after step 3 of forward elimination:
    2.00   -1.00    1.00    3.00
    0.00    1.50    0.50    4.50
    0.00    0.00    1.67    2.00
 
    Solution:
    x1 = 2.20
    x2 = 2.60
    x3 = 1.20
        
        </pre>

</div>
</div>
<div id="section9">
    <br>
    <h3>9.Gauss Jordan Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

#define N 3  // Size of the matrix
    
void printMatrix(double matrix[N][N+1]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N+1; j++) {
            printf("%7.2lf ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
    
void gaussJordanElimination(double matrix[N][N+1]) {
    int i, j, k;
    double ratio;
    
// Forward elimination to get the matrix in row echelon form
for (i = 0; i < N; i++) {
// Make the diagonal element 1 and eliminate other elements in the column
    double diag = matrix[i][i];
    for (j = 0; j < N+1; j++) {
        matrix[i][j] /= diag;
    }
    for (j = 0; j < N; j++) {
        if (i != j) {
            ratio = matrix[j][i];
            for (k = 0; k < N+1; k++) {
                matrix[j][k] -= ratio * matrix[i][k];
            }
        }
    }
    // Print matrix after each step of Gauss-Jordan elimination
    printf("Matrix after step %d of Gauss-Jordan elimination:\n", i+1);
    printMatrix(matrix);
    }
}
    
int main() {
double matrix[N][N+1] = {
    {2,-1, 1, 3},  // Example system: 2x - y + z = 3
    {1, 1, 1, 6},   //            x +   y + z = 6
    {1, -1, 2, 2}   //            x - y + 2z = 2
};
    
printf("Augmented Matrix:\n");
printMatrix(matrix);
    
gaussJordanElimination(matrix);
    
// Print the solution
printf("Solution:\n");
for (int i = 0; i < N; i++) {
    printf("x%d = %.2lf\n", i+1, matrix[i][N]);
}
        return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Augmented Matrix:
    2.00   -1.00    1.00    3.00
    1.00    1.00    1.00    6.00
    1.00   -1.00    2.00    2.00
 
    Matrix after step 1 of Gauss-Jordan elimination:
    1.00   -0.50    0.50    1.50
    0.00    1.50    0.50    4.50
    0.00   -0.50    1.50    0.50
 
    Matrix after step 2 of Gauss-Jordan elimination:
    1.00    0.00    0.67    3.00
    0.00    1.00    0.33    3.00
    0.00    0.00    1.67    2.00
 
    Matrix after step 3 of Gauss-Jordan elimination:
    1.00    0.00    0.00    2.20
    0.00    1.00    0.00    2.60
    0.00    0.00    1.00    1.20
 
    Solution:
    x1 = 2.20
    x2 = 2.60
    x3 = 1.20

</pre>
</div>
</div>
<div id="section10">
    <br>
    <h3>10.Gauss Seidel Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >
#include < math.h >
    
#define MAX_ITER 100    // Maximum number of iterations
#define EPSILON 1e-6    // Convergence tolerance
    
    // Function to implement Gauss-Seidel Iteration
    void gaussSeidel(int n, double a[n][n], double b[n],
     double x[n]) {
        double newX[n];
        int iteration = 0;
        double maxError;
    
        // Initialize the solution vector to 0 
        (or any initial guess)
        for (int i = 0; i < n; i++) {
            x[i] = 0.0;
        }
    
        do {
            maxError = 0.0;
            for (int i = 0; i < n; i++) {
                double sum = b[i];
    
                // Calculate the sum for non-diagonal elements
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        sum -= a[i][j] * x[j];
                    }
                }
                // Calculate the updated value
                newX[i] = sum / a[i][i];
    
                // Calculate the error
                double error = fabs(newX[i] - x[i]);
                if (error > maxError) {
                    maxError = error;
                }
    
                // Update the current solution
                x[i] = newX[i];
            }
    
            iteration++;
        } while (maxError > EPSILON && iteration < MAX_ITER);
    
        if (iteration < MAX_ITER) {
            printf("Converged in %d iterations.\n", iteration);
        } else {
            printf("Did not converge within the maximum 
            number of iterations.\n");
        }
    }
    
    // Main function to test Gauss-Seidel
    int main() {
        int n;
    
        // Input the size of the system
        printf("Enter the number of variables: ");
        scanf("%d", &n);
    
        double a[n][n], b[n], x[n];
        // Input the coefficients matrix 'a'
        printf("Enter the coefficients of the matrix 
        (row-wise):\n");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                scanf("%lf", &a[i][j]);
            }
        }
    
        // Input the constants vector 'b'
        printf("Enter the constants vector:\n");
        for (int i = 0; i < n; i++) {
            scanf("%lf", &b[i]);
        }
    
        // Run Gauss-Seidel
        gaussSeidel(n, a, b, x);
    
        // Print the solution
        printf("The solution is:\n");
        for (int i = 0; i < n; i++) {
            printf("x[%d] = %0.6f\n", i, x[i]);
        }
    
        return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of variables: 3
    Enter the coefficients of the matrix (row-wise):
    4 1 2
    1 3 1
    2 1 3
    Enter the constants vector:
    4
    5
    7
    Converged in 15 iterations.
    The solution is:
    x[0] = 0.614379
    x[1] = 1.421053
    x[2] = 1.719298
</pre>
</div>
</div>
<div id="section11">
    <br>
    <h3>11.Lagrange's Interpolation Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function to calculate the interpolation value at x
double lagrangeInterpolation(int n, double x[], 
double y[], double xp) {
    double result = 0.0;

    for (int i = 0; i < n; i++) {
        double term = y[i];
        for (int j = 0; j < n; j++) {
            if (j != i) {
                term *= (xp - x[j]) / (x[i] - x[j]);
            }
        }
        result += term;
    }

    return result;
}

// Main function to test Lagrange's Interpolation
int main() {
    int n;
    printf("Enter the number of data points: ");
    scanf("%d", &n);

    double x[n], y[n];
    printf("Enter the data points (x y):\n");
    for (int i = 0; i < n; i++) {
        scanf("%lf %lf", &x[i], &y[i]);
    }
    double xp;
    printf("Enter the point at which to interpolate: ");
    scanf("%lf", &xp);

    double yp = lagrangeInterpolation(n, x, y, xp);
    printf("Interpolated value at x = %.3f is y = %.3f\n"
    , xp, yp);

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of data points: 3
    Enter the data points (x y):
    1 1
    2 4
    3 9
    Enter the point at which to interpolate: 1.5

    Interpolated value at x = 1.500 is y = 2.500
</pre>
</div>
</div>
<div id="section12">
    <br>
    <h3>12.Lagrange's Inverse Interpolation Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

//Function to calculate the inverse interpolation value at y
double lagrangeInverseInterpolation(int n, double x[],
 double y[], double yp) {
double result = 0.0;

for (int i = 0; i < n; i++) {
    double term = x[i];
    for (int j = 0; j < n; j++) {
        if (j != i) {
            term *= (yp - y[j]) / (y[i] - y[j]);
        }
    }
    result += term;
}

return result;
}

// Main function to test Lagrange's Inverse Interpolation
int main() {
int n;
printf("Enter the number of data points: ");
scanf("%d", &n);

double x[n], y[n];
printf("Enter the data points (x y):\n");
for (int i = 0; i < n; i++) {
    scanf("%lf %lf", &x[i], &y[i]);
}

double yp;
    printf("Enter the y value at which to find x: ");
    scanf("%lf", &yp);

    double xp = lagrangeInverseInterpolation(n, x, y, yp);
    printf("Estimated x value at y = %.3f is x = %.3f\n", yp, xp);

    return 0;
    }
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of data points: 3
    Enter the data points (x y):
    1 1
    2 4
    3 9
    Enter the y value at which to find x: 5
    Estimated x value at y = 5.000 is x = 2.236
</pre>
</div>
</div>
<div id="section13">
    <br>
    <h3>13.Newton Forward difference Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function to calculate factorial
int factorial(int n) {
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
    }
    return fact;
}

// Function to calculate the interpolated value
 at a given point using Newton Forward Difference
double newtonForwardInterpolation
(int n, double x[], double y[][n], double xp) {
    // Compute forward difference table
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < n - i; j++) {
            y[j][i] = y[j + 1][i - 1] - y[j][i - 1];
        }
    }

    // Display the forward difference table (optional)
    printf("Forward Difference Table:\n");
    for (int i = 0; i < n; i++) {
        printf("%0.3f", x[i]);
        for (int j = 0; j < n - i; j++) {
            printf("\t%0.3f", y[i][j]);
        }
        printf("\n");
    }
    // Calculate the interpolated value at xp
    double result = y[0][0];
    double u = (xp - x[0]) / (x[1] - x[0]);
    double u_term = 1;

    for (int i = 1; i < n; i++) {
        u_term *= (u - i + 1);
        result += (u_term * y[0][i]) / factorial(i);
    }

    return result;
}

int main() {
    int n;
    printf("Enter the number of data points: ");
    scanf("%d", &n);

    double x[n], y[n][n];
    printf("Enter the data points (x y):\n");
    for (int i = 0; i < n; i++) {
        scanf("%lf %lf", &x[i], &y[i][0]);
    }

    double xp;
    printf("Enter the value of x at which to interpolate: ");
    scanf("%lf", &xp);

    double yp = newtonForwardInterpolation(n, x, y, xp);
    printf("Interpolated value at x = %.3f is
     y = %.3f\n", xp, yp);

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of data points: 4
    Enter the data points (x y):
    1 1
    2 8
    3 27
    4 64
    Enter the value of x at which to interpolate: 2.5
    Forward Difference Table:
    1.000   1.000   7.000   12.000  6.000
    2.000   8.000   19.000  18.000
    3.000   27.000  37.000
    4.000   64.000

    Interpolated value at x = 2.500 is y = 15.625
</pre>
</div>
</div>
<div id="section14">
    <br>
    <h3>14.Newton Backward difference Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function to calculate factorial
int factorial(int n) {
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
    }
    return fact;
}

// Function to calculate the interpolated value at
   a given point using Newton Backward Difference
double newtonBackwardInterpolation(int n, double x[]
, double y[][n], double xp) {
    // Compute backward difference table
    for (int i = 1; i < n; i++) {
        for (int j = n - 1; j >= i; j--) {
            y[j][i] = y[j][i - 1] - y[j - 1][i - 1];
        }
    }

    // Display the backward difference table (optional)
    printf("Backward Difference Table:\n");
    for (int i = 0; i < n; i++) {
        printf("%0.3f", x[i]);
        for (int j = 0; j <= i; j++) {
            printf("\t%0.3f", y[i][j]);
        }
        printf("\n");
    }
    // Calculate the interpolated value at xp
    double result = y[n - 1][0];
    double u = (xp - x[n - 1]) / (x[1] - x[0]);
    double u_term = 1;

    for (int i = 1; i < n; i++) {
        u_term *= (u + i - 1);
        result += (u_term * y[n - 1][i]) / factorial(i);
    }

    return result;
}

int main() {
    int n;
    printf("Enter the number of data points: ");
    scanf("%d", &n);

    double x[n], y[n][n];
    printf("Enter the data points (x y):\n");
    for (int i = 0; i < n; i++) {
        scanf("%lf %lf", &x[i], &y[i][0]);
    }

    double xp;
    printf("Enter the value of x at which to interpolate: ");
    scanf("%lf", &xp);

    double yp = newtonBackwardInterpolation(n, x, y, xp);
    printf("Interpolated value at x = %.3f is y = %.3f\n", xp, yp);

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of data points: 4
    Enter the data points (x y):
    1 1
    2 8
    3 27
    4 64
    Enter the value of x at which to interpolate: 3.5
    Backward Difference Table:
    1.000   1.000
    2.000   8.000   7.000
    3.000   27.000  19.000  12.000
    4.000   64.000  37.000  18.000  6.000

    Interpolated value at x = 3.500 is y = 42.875
</pre>
</div>
</div>
<div id="section15">
    <br>
    <h3>15.Newton's Divided Difference Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
##include < stdio.h >

// Function to calculate the interpolated value
 at a given point using Newton's Divided Difference
double newtonDividedDifference(int n, double x[]
, double y[], double xp) {
double table[n][n];

// Initialize first column with y values
for (int i = 0; i < n; i++) {
    table[i][0] = y[i];
}

// Calculate divided differences and fill the table
for (int j = 1; j < n; j++) {
    for (int i = 0; i < n - j; i++) {
        table[i][j] = (table[i + 1][j - 1] - 
        table[i][j - 1]) / (x[i + j] - x[i]);
    }
}

// Display the divided difference table (optional)
printf("Divided Difference Table:\n");
for (int i = 0; i < n; i++) {
    printf("%0.3f", x[i]);
    for (int j = 0; j < n - i; j++) {
        printf("\t%0.3f", table[i][j]);
    }
    printf("\n");
}
// Calculate the interpolated value at xp
double result = table[0][0];
double term = 1.0;

for (int i = 1; i < n; i++) {
    term *= (xp - x[i - 1]);
    result += term * table[0][i];
}

return result;
}

int main() {
int n;
printf("Enter the number of data points: ");
scanf("%d", &n);

double x[n], y[n];
printf("Enter the data points (x y):\n");
for (int i = 0; i < n; i++) {
    scanf("%lf %lf", &x[i], &y[i]);
}

double xp;
printf("Enter the value of x at which to interpolate: ");
scanf("%lf", &xp);

double yp = newtonDividedDifference(n, x, y, xp);
printf("Interpolated value at x = %.3f is 
y = %.3f\n", xp, yp);

return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of data points: 4
    Enter the data points (x y):
    1 1
    2 8
    3 27
    4 64
    Enter the value of x at which to interpolate: 2.5
    Divided Difference Table:
    1.000   1.000   7.000   6.000   0.000
    2.000   8.000   19.000  6.000
    3.000   27.000  37.000
    4.000   64.000

    Interpolated value at x = 2.500 is y = 15.625
</pre>
</div>
</div>
<div id="section16">
    <br>
    <h3>16.Trapzoidal Rule Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Define the function to integrate
double f(double x) {
    return x * x;  // Example function: f(x) = x^2
}

// Function to calculate the integral using the Trapezoidal Rule
double trapezoidalRule(double a, double b, int n) {
    double h = (b - a) / n;  // Width of each subinterval
    double sum = f(a) + f(b);  // Initialize sum with f(a) and f(b)

// Sum the middle terms with a factor of 2
    for (int i = 1; i < n; i++) {
    double x_i = a + i * h;
    sum += 2 * f(x_i);
}

// Apply the trapezoidal formula
double result = (h / 2) * sum;
return result;
}
int main() {
    double a, b;
    int n;

    printf("Enter the lower limit of integration (a): ");
    scanf("%lf", &a);
    printf("Enter the upper limit of integration (b): ");
    scanf("%lf", &b);
    printf("Enter the number of subintervals (n): ");
    scanf("%d", &n);

    double result = trapezoidalRule(a, b, n);
    printf("Approximate value of the integral using the Trapezoidal 
    Rule is: %.6f\n", result);

    return 0;
    }
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the lower limit of integration (a): 0
    Enter the upper limit of integration (b): 1
    Enter the number of subintervals (n): 4
    Approximate value of the integral using the 
    Trapezoidal Rule is: 0.343750
</pre>
</div>
</div>
<div id="section17">
    <br>
    <h3>17.Simpson 1/3 th Rule Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Define the function to integrate
double f(double x) {
return x * x;  // Example function: f(x) = x^2
}

// Function to calculate the integral using Simpson's 1/3 Rule
double simpsonsOneThirdRule(double a, double b, int n) {
if (n % 2 != 0) {
    printf("Simpson's 1/3 Rule requires an even number of
     subintervals.\n");
    return -1;
}

double h = (b - a) / n;  // Width of each subinterval
double sum = f(a) + f(b);  // Initialize sum with f(a) and f(b)

// Sum up the odd and even terms with appropriate coefficients
for (int i = 1; i < n; i++) {
    double x_i = a + i * h;
    if (i % 2 == 0) {
        sum += 2 * f(x_i);
    } else {
        sum += 4 * f(x_i);
    }
}

// Apply Simpson's 1/3 formula
double result = (h / 3) * sum;
return result;
}
int main() {
    double a, b;
    int n;

    printf("Enter the lower limit of integration (a): ");
    scanf("%lf", &a);
    printf("Enter the upper limit of integration (b): ");
    scanf("%lf", &b);
    printf("Enter the number of subintervals (n): ");
    scanf("%d", &n);

    double result = simpsonsOneThirdRule(a, b, n);
    if (result != -1) {
        printf("Approximate value of the integral using Simpson's
         1/3 Rule is: %.6f\n", result);
    }

    return 0;
    }
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the lower limit of integration (a): 0
    Enter the upper limit of integration (b): 1
    Enter the number of subintervals (n): 4
    Approximate value of the integral using Simpson's 1/3 Rule is: 0.333333

</div>
</div>
<div id="section18">
    <br>
    <h3>18.Simpson 3/8 th Rule Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Define the function to integrate
double f(double x) {
return x * x;  // Example function: f(x) = x^2
}

// Function to calculate the integral using 
Simpson's 3/8 Rule
double simpsonsThreeEighthRule(double a, double b, int n) {
if (n % 3 != 0) {
    printf("Simpson's 3/8 Rule requires the number 
    of subintervals to be a multiple of 3.\n");
    return -1;
}

double h = (b - a) / n;  // Width of each subinterval
double sum = f(a) + f(b);  

// Sum up the terms with appropriate coefficients
for (int i = 1; i < n; i++) {
    double x_i = a + i * h;
    if (i % 3 == 0) {
        sum += 2 * f(x_i);
    } else {
        sum += 3 * f(x_i);
    }
}

// Apply Simpson's 3/8 formula
double result = (3 * h / 8) * sum;
return result;
}
int main() {
    double a, b;
    int n;

    printf("Enter the lower limit of integration (a): ");
    scanf("%lf", &a);
    printf("Enter the upper limit of integration (b): ");
    scanf("%lf", &b);
    printf("Enter the number of subintervals (n, must be 
    a multiple of 3): ");
    scanf("%d", &n);

    double result = simpsonsThreeEighthRule(a, b, n);
    if (result != -1) {
        printf("Approximate value of the integral using 
        Simpson's 3/8 Rule is: %.6f\n", result);
    }

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the lower limit of integration (a): 0
    Enter the upper limit of integration (b): 1
    Enter the number of subintervals (n, must be a multiple of 3): 3
            
    Approximate value of the integral using Simpson's 3/8 Rule is: 0.333333
</pre>
</div>
</div>
<div id="section19">
    <br>
    <h3>19.Taylor Series Representation</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function to calculate e^x using Taylor series expansion
double exponentialTaylorSeries(double x, int n) {
double sum = 1.0;  // Start with the first term (1)
double term = 1.0; // Initialize term for the series

// Calculate each term and add to sum
for (int i = 1; i <= n; i++) {
    term *= x / i;  // Calculate the next term
    sum += term;    // Add the term to the sum
}

return sum;
}

int main() {
double x;
int n;

printf("Enter the value of x: ");
scanf("%lf", &x);
printf("Enter the number of terms (n) for Taylor series: ");
scanf("%d", &n);

double result = exponentialTaylorSeries(x, n);
printf("Approximation of e^%.2f using Taylor series 
(up to %d terms) is: %.6f\n", x, n, result);

return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the value of x: 1
    Enter the number of terms (n) for Taylor series: 10
    Approximation of e^1.00 using Taylor series (up to 10 terms) is: 2.718281

</pre>
</div>
</div>
<div id="section20">
    <br>
    <h3>20.Chebyshev Polynomials</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >
#include < math.h >

// Function to calculate Chebyshev polynomial
of the first kind
double chebyshev(int n, double x) {
if (n == 0) return 1;
if (n == 1) return x;

double Tn_2 = 1; // T_0(x)
double Tn_1 = x; // T_1(x)
double Tn;

for (int i = 2; i <= n; i++) {
    Tn = 2 * x * Tn_1 - Tn_2; // Recursive relation
    Tn_2 = Tn_1; // Update for next iteration
    Tn_1 = Tn;
}

return Tn;
}
int main() {
    int n;
    double x;

    printf("Enter the number of Chebyshev polynomials 
    to calculate (n): ");
    scanf("%d", &n);
    printf("Enter the value of x (in [-1, 1]): ");
    scanf("%lf", &x);

    printf("Chebyshev Polynomials of the first kind up 
    to T_%d(%f):\n", n, x);
    for (int i = 0; i <= n; i++) {
        printf("T_%d(%f) = %.6f\n", i, x, chebyshev(i, x));
    }

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the number of Chebyshev polynomials to calculate (n): 4
    Enter the value of x (in [-1, 1]): 0.5
    Chebyshev Polynomials of the first kind up to T_4(0.500000):
    T_0(0.500000) = 1.000000
    T_1(0.500000) = 0.500000
    T_2(0.500000) = -0.500000
    T_3(0.500000) = -1.500000
    T_4(0.500000) = 1.000000

</pre>
</div>
</div>
<div id="section21">
    <br>
    <h3>21.Euler’s Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function that defines the ODE dy/dt = f(t, y)
double f(double t, double y) {
return t + y;  // Example function: dy/dt = t + y
}

// Euler's Method to approximate the solution of the ODE
void euler(double t0, double y0, double h, double t_end) {
double t = t0;
double y = y0;

printf("t\t\ty\n");
printf("%.2f\t\t%.6f\n", t, y);  // Print initial values

// Iterate until the current t is less than or equal to t_end
while (t < t_end) {
    y += h * f(t, y);  // Update y
    t += h;            // Update t
    printf("%.2f\t\t%.6f\n", t, y);  // Print current values
}
}

int main() {
    double t0, y0, h, t_end;

    printf("Enter the initial value of t (t0): ");
    scanf("%lf", &t0);
    printf("Enter the initial value of y (y0): ");
    scanf("%lf", &y0);
    printf("Enter the step size (h): ");
    scanf("%lf", &h);
    printf("Enter the end value of t (t_end): ");
    scanf("%lf", &t_end);

    euler(t0, y0, h, t_end);  // Call the Euler function

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the initial value of t (t0): 0
    Enter the initial value of y (y0): 1
    Enter the step size (h): 0.1
    Enter the end value of t (t_end): 1
    t          y
    0.00      1.000000
    0.10      1.100000
    0.20      1.210000
    0.30      1.331000
    0.40      1.464100
    0.50      1.610510
    0.60      1.771561
    0.70      1.948717
    0.80      2.143588
    0.90      2.357646
    1.00      2.592411

</pre>
</div>
</div>
<div id="section22">
    <br>
    <h3>22.Runga–Kutta Methods: 2nd order</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function that defines the ODE dy/dt = f(t, y)
double f(double t, double y) {
return t + y;  // Example function: dy/dt = t + y
}

// Second-order Runge-Kutta Method to approximate
 the solution of the ODE
void rungeKutta2(double t0, double y0, double h,
 double t_end) {
double t = t0;
double y = y0;

printf("t\t\ty\n");
printf("%.2f\t\t%.6f\n", t, y);  // Print initial values

// Iterate until the current t is less than or equal to t_end
while (t < t_end) {
    double k1 = h * f(t, y);  // Calculate k1
    double k2 = h * f(t + h / 2, y + k1 / 2);  // Calculate k2
    y += k2;                   // Update y
    t += h;                   // Update t
    printf("%.2f\t\t%.6f\n", t, y);  // Print current values
}
}
int main() {
    double t0, y0, h, t_end;

    printf("Enter the initial value of t (t0): ");
    scanf("%lf", &t0);
    printf("Enter the initial value of y (y0): ");
    scanf("%lf", &y0);
    printf("Enter the step size (h): ");
    scanf("%lf", &h);
    printf("Enter the end value of t (t_end): ");
    scanf("%lf", &t_end);

    rungeKutta2(t0, y0, h, t_end);  // Call the RK2 function

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the initial value of t (t0): 0
    Enter the initial value of y (y0): 1
    Enter the step size (h): 0.1
    Enter the end value of t (t_end): 1
            
    t          y
    0.00      1.000000
    0.10      1.100000
    0.20      1.210000
    0.30      1.331000
    0.40      1.464100
    0.50      1.610510
    0.60      1.771561
    0.70      1.948717
    0.80      2.143588
    0.90      2.357646
    1.00      2.592411
</pre>
</div>
</div>
<div id="section23">
    <br>
    <h3>23.Runga–Kutta Methods: 4th order</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function that defines the ODE dy/dt = f(t, y)
double f(double t, double y) {
return t + y;  // Example function: dy/dt = t + y
}

// Fourth-order Runge-Kutta Method to 
approximate the solution of the ODE
void rungeKutta4(double t0, double y0, 
double h, double t_end) {
double t = t0;
double y = y0;

printf("t\t\ty\n");
printf("%.2f\t\t%.6f\n", t, y);  // Print initial values

// Iterate until the current t is less than or equal to t_end
while (t < t_end) {
    double k1 = h * f(t, y);  // Calculate k1
    double k2 = h * f(t + h / 2, y + k1 / 2);  // Calculate k2
    double k3 = h * f(t + h / 2, y + k2 / 2);  // Calculate k3
    double k4 = h * f(t + h, y + k3);  // Calculate k4
    
    y += (k1 + 2 * k2 + 2 * k3 + k4) / 6;  // Update y
    t += h;  // Update t
    
    printf("%.2f\t\t%.6f\n", t, y);  // Print current values
}
}

int main() {
    double t0, y0, h, t_end;

    printf("Enter the initial value of t (t0): ");
    scanf("%lf", &t0);
    printf("Enter the initial value of y (y0): ");
    scanf("%lf", &y0);
    printf("Enter the step size (h): ");
    scanf("%lf", &h);
    printf("Enter the end value of t (t_end): ");
    scanf("%lf", &t_end);

    rungeKutta4(t0, y0, h, t_end);  // Call the RK4 function

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the initial value of t (t0): 0
    Enter the initial value of y (y0): 1
    Enter the step size (h): 0.1
    Enter the end value of t (t_end): 1
            
    t          y
    0.00      1.000000
    0.10      1.100500
    0.20      1.210720
    0.30      1.331037
    0.40      1.464646
    0.50      1.610617
    0.60      1.771153
    0.70      1.948565
    0.80      2.143198
    0.90      2.357404
    1.00      2.592650

</pre>
</div>
</div>
<div id="section24">
    <br>
    <h3>24.Modified Euler’s Method</h3>
    <br>
    <h4>Code : </h4>
    <br>
    <div class="sec1">
        <pre>
#include < stdio.h >

// Function that defines the ODE dy/dt = f(t, y)
double f(double t, double y) {
return t + y;  // Example function: dy/dt = t + y
}

// Modified Euler's Method to approximate 
the solution of the ODE
void modifiedEuler(double t0, double y0,
double h, double t_end) {
double t = t0;
double y = y0;

printf("t\t\ty\n");
printf("%.2f\t\t%.6f\n", t, y);  
// Iterate until the current t is
 less than or equal to t_end
while (t < t_end) {
    double y_predict = y + h * f(t, y);  
    y += (h / 2) * (f(t, y) + f(t + h, y_predict)); 
    t += h;  // Update t
    
    printf("%.2f\t\t%.6f\n", t, y);  
}
}

int main() {
    double t0, y0, h, t_end;

    printf("Enter the initial value of t (t0): ");
    scanf("%lf", &t0);
    printf("Enter the initial value of y (y0): ");
    scanf("%lf", &y0);
    printf("Enter the step size (h): ");
    scanf("%lf", &h);
    printf("Enter the end value of t (t_end): ");
    scanf("%lf", &t_end);

    modifiedEuler(t0, y0, h, t_end);  

    return 0;
}
</pre>
    </div>

    <div class="sec2">
        <br>
        <h4>Output : </h4>
        <pre>
    Enter the initial value of t (t0): 0
    Enter the initial value of y (y0): 1
    Enter the step size (h): 0.1
    Enter the end value of t (t_end): 1
    
    t          y
    0.00      1.000000
    0.10      1.100500
    0.20      1.210020
    0.30      1.331024
    0.40      1.464141
    0.50      1.610665
    0.60      1.771420
    0.70      1.948564
    0.80      2.143198
    0.90      2.357382
    1.00      2.592668
</pre>
</div>
</div>
</section>
</div>
</body>
</html>